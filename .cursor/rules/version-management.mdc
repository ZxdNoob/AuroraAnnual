---
description: 版本管理规范和更新流程
alwaysApply: true
---

# 版本管理规范

## 版本号规范

### 语义化版本（SemVer）

项目严格遵循 [语义化版本 2.0.0](https://semver.org/lang/zh-CN/) 规范，版本号格式为：**`MAJOR.MINOR.PATCH`**（主版本号.次版本号.修订号）

- **MAJOR（主版本号 x）**：当你做了不兼容的 API 修改
  - 重大功能变更
  - 破坏性变更（Breaking Changes）
  - 架构重构
  - 示例：`1.0.0` → `2.0.0`

- **MINOR（次版本号 y）**：当你做了向下兼容的功能性新增
  - 新功能添加
  - 新子项目创建
  - 功能增强
  - 示例：`1.0.0` → `1.1.0`

- **PATCH（修订号 z）**：当你做了向下兼容的问题修正
  - Bug 修复
  - 文档更新
  - 代码优化
  - 示例：`1.0.0` → `1.0.1`

### 版本号规则

- 版本号必须严格遵循 `x.y.z` 格式，其中 x、y、z 都是非负整数
- 版本号从 `0.1.0` 开始（初始开发版本）
- 主版本号为 `0` 时表示项目处于初始开发阶段，API 可能随时改变
- 主版本号为 `1` 或以上时，表示项目已稳定，遵循语义化版本规范
- 禁止使用 `0.0.x` 版本号（应使用 `0.1.0` 作为初始版本）

### 预发布版本（可选）

如果需要发布预发布版本，可以在版本号后追加标识符：

- **Alpha 版本**：`1.0.0-alpha.1`、`1.0.0-alpha.2`
- **Beta 版本**：`1.0.0-beta.1`、`1.0.0-beta.2`
- **RC 版本**：`1.0.0-rc.1`、`1.0.0-rc.2`

## 版本更新流程

### 更新前检查清单

在更新版本号之前，必须完成以下检查：

1. ✅ 确认所有代码变更已完成并测试通过
2. ✅ 确认所有文档已更新
3. ✅ 确认提交信息符合规范
4. ✅ 确认版本号符合语义化版本规范

### 版本更新步骤

1. **确定版本号类型**
   - 根据变更内容确定是 MAJOR、MINOR 还是 PATCH 版本更新

2. **更新版本号文件**
   - 如果项目有 `package.json`，更新其中的 `version` 字段
   - 如果项目有 `VERSION` 文件，更新其中的版本号
   - 如果项目有 `version.txt` 或其他版本文件，同步更新

3. **更新 README.md**
   - 在 README.md 的"更新记录"部分添加新版本信息
   - 格式：`- **版本 x.y.z**：YYYY-MM-DD hh:mm:ss - 更新说明`
   - **必须更新"最后更新时间"字段**：严格按照时间更新规范执行
     - 更新前必须独立执行 `date` 命令获取当前精确时间
     - 时间格式必须使用 `YYYY-MM-DD hh:mm:ss` 格式
     - 不能复用之前的时间，必须重新获取

4. **更新 CHANGELOG.md（如果存在）**
   - 在 CHANGELOG.md 中添加新版本条目
   - 按照 [Keep a Changelog](https://keepachangelog.com/zh-CN/1.0.0/) 格式编写
   - 分类列出变更：Added、Changed、Deprecated、Removed、Fixed、Security

5. **更新 Git 标签**
   - 创建版本标签：`git tag -a vx.y.z -m "版本 x.y.z 发布说明"`
   - 推送标签：`git push origin vx.y.z`

6. **提交版本更新**
   - 提交信息格式：`🏷️ version: 更新版本号至 x.y.z`
   - 包含所有版本相关文件的更新

## 需要更新的文件清单

每次更新版本号时，必须同步更新以下文件：

### 必须更新的文件

1. **README.md**
   - 更新记录部分
   - 最后更新时间

2. **版本号文件**（如果存在）
   - `package.json` 中的 `version` 字段
   - `VERSION` 文件
   - `version.txt` 文件
   - 其他版本声明文件

3. **CHANGELOG.md**（如果存在）
   - 添加新版本条目
   - 详细记录变更内容

### 可选更新的文件

1. **项目配置文件**
   - `package.json` 中的其他版本相关字段
   - 其他配置文件中的版本信息

2. **文档文件**
   - 项目文档中的版本引用
   - API 文档中的版本信息

## 版本更新示例

### 示例 1：PATCH 版本更新（1.0.0 → 1.0.1）

**变更内容**：修复文档中的拼写错误

**需要更新的文件**：

- README.md：更新记录和最后更新时间
- CHANGELOG.md：添加 1.0.1 版本条目，记录修复内容

**提交信息**：

```text
🏷️ version: 更新版本号至 1.0.1

- 修复文档中的拼写错误
- 更新 README.md 更新记录
```

### 示例 2：MINOR 版本更新（1.0.0 → 1.1.0）

**变更内容**：新增 2025To2026 年度子项目

**需要更新的文件**：

- README.md：更新记录、最后更新时间、项目结构说明
- CHANGELOG.md：添加 1.1.0 版本条目，记录新增功能

**提交信息**：

```text
✨ feat(2025To2026): 新增 2025To2026 年度子项目
🏷️ version: 更新版本号至 1.1.0

- 新增 2025To2026 年度子项目目录
- 更新 README.md 项目结构说明
- 更新版本号至 1.1.0
```

### 示例 3：MAJOR 版本更新（1.0.0 → 2.0.0）

**变更内容**：重构项目结构，改变子项目命名规范

**需要更新的文件**：

- README.md：更新记录、最后更新时间、项目结构说明
- CHANGELOG.md：添加 2.0.0 版本条目，记录破坏性变更
- 所有相关文档

**提交信息**：

```text
🚨 breaking(structure): 重构项目结构，改变子项目命名规范
🏷️ version: 更新版本号至 2.0.0

- 重构项目目录结构
- 改变子项目命名规范（从 YYYY 改为 thisYearToNextYear 格式，如 2025To2026）
- 更新所有相关文档
- 更新版本号至 2.0.0
```

## 版本号验证

### 版本号格式验证

版本号必须符合以下正则表达式：

```regex
^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$
```

### 版本号比较规则

- `1.0.0` < `2.0.0` < `2.1.0` < `2.1.1`
- `1.0.0-alpha` < `1.0.0-alpha.1` < `1.0.0-alpha.beta` < `1.0.0-beta` < `1.0.0-beta.2` < `1.0.0-beta.11` < `1.0.0-rc.1` < `1.0.0`

## 主项目和子项目版本独立性

### 核心原则

**主项目和子项目的版本号是独立的，互不影响。**

### 版本独立性规则

1. **子项目版本独立**
   - 每个子项目（如 `2025To2026`）拥有独立的版本号
   - 子项目的版本号存储在子项目目录下的版本文件中（如 `VERSION`、`package.json`）
   - 子项目的版本号遵循语义化版本规范（SemVer）

2. **版本升级独立性**
   - **子项目版本升级不会让主项目升级**
     - 子项目的功能更新、Bug 修复、版本升级等，不会影响主项目的版本号
     - 例如：`2025To2026` 从 `1.0.0` 升级到 `1.1.0`，主项目版本号保持不变
   
   - **主项目版本升级不一定会让某个子项目版本升级**
     - 主项目的版本升级（如项目结构变更、规则更新、文档更新等）不会自动触发子项目版本升级
     - 只有当主项目的变更直接影响某个子项目时，才需要升级该子项目的版本号
     - 例如：主项目从 `0.2.0` 升级到 `0.3.0`（更新了项目规则），`2025To2026` 子项目版本号保持不变

3. **主项目版本升级场景**
   - 主项目版本号仅在以下情况升级：
     - 项目结构变更（如目录结构、命名规范等）
     - 项目规则更新（如 `.cursor/rules/` 下的规则文件更新）
     - 主项目 README.md 的重大更新
     - 跨年新增子项目（通常为 MINOR 版本更新）
     - 主项目级别的架构重构

4. **子项目版本升级场景**
   - 子项目版本号在以下情况升级：
     - 子项目功能更新（新增功能、功能增强）
     - 子项目 Bug 修复
     - 子项目依赖更新（特别是 MAJOR 版本升级）
     - 子项目架构重构
     - 子项目文档更新（通常为 PATCH 版本更新）

### 版本文件管理

#### 主项目版本文件

- **位置**：项目根目录 `VERSION`
- **格式**：`x.y.z`（如 `0.2.0`）
- **更新时机**：主项目级别的变更

#### 子项目版本文件

- **位置**：子项目目录下（如 `2025To2026/VERSION`）
- **格式**：`x.y.z`（如 `1.0.0`）
- **更新时机**：子项目级别的变更
- **可选位置**：
  - `子项目目录/VERSION`（推荐）
  - `子项目目录/package.json` 中的 `version` 字段（如果子项目是 Node.js 项目）
  - 子项目 README.md 中的版本信息

### 版本升级示例

#### 示例 1：子项目升级，主项目不变

**场景**：`2025To2026` 子项目新增了用户认证功能

**版本变更**：
- 主项目：`0.2.0` → `0.2.0`（不变）
- 子项目 `2025To2026`：`1.0.0` → `1.1.0`（MINOR 版本更新）

**需要更新的文件**：
- `2025To2026/VERSION`：更新为 `1.1.0`
- `2025To2026/README.md`：更新版本信息和更新记录
- `2025To2026/docs/version-updates/`：创建版本更新文档

#### 示例 2：主项目升级，子项目不变

**场景**：主项目更新了版本管理规范，新增了主项目和子项目版本独立性规则

**版本变更**：
- 主项目：`0.2.0` → `0.3.0`（MINOR 版本更新）
- 子项目 `2025To2026`：`1.0.0` → `1.0.0`（不变）

**需要更新的文件**：
- 根目录 `VERSION`：更新为 `0.3.0`
- 根目录 `README.md`：更新版本信息和更新记录

#### 示例 3：主项目和子项目同时升级（独立原因）

**场景**：
- 主项目：更新了项目规则文件
- 子项目 `2025To2026`：修复了一个 Bug

**版本变更**：
- 主项目：`0.2.0` → `0.3.0`（MINOR 版本更新，因为规则更新）
- 子项目 `2025To2026`：`1.0.0` → `1.0.1`（PATCH 版本更新，因为 Bug 修复）

**需要更新的文件**：
- 根目录 `VERSION`：更新为 `0.3.0`
- 根目录 `README.md`：更新版本信息
- `2025To2026/VERSION`：更新为 `1.0.1`
- `2025To2026/README.md`：更新版本信息

### 版本号命名规范

#### 主项目版本号

- 格式：`x.y.z`
- 示例：`0.2.0`、`1.0.0`、`2.1.0`
- 存储位置：根目录 `VERSION`

#### 子项目版本号

- 格式：`x.y.z`
- 示例：`1.0.0`、`1.1.0`、`2.0.0`
- 存储位置：子项目目录下的 `VERSION` 或 `package.json`
- 命名建议：子项目版本号从 `1.0.0` 开始（表示子项目已稳定）

### AI 助手行为规范

#### 版本更新时的判断逻辑

1. **判断变更范围**
   - 如果变更仅在子项目目录内（如 `2025To2026/`），只更新子项目版本
   - 如果变更在主项目目录（如根目录、`.cursor/rules/`），只更新主项目版本
   - 如果变更同时影响主项目和子项目，分别更新各自的版本号

2. **版本号类型判断**
   - 根据变更内容判断是 MAJOR、MINOR 还是 PATCH 版本更新
   - 主项目和子项目独立判断版本号类型

3. **文件更新**
   - 主项目版本更新：更新根目录 `VERSION` 和 `README.md`
   - 子项目版本更新：更新子项目目录下的版本文件和 `README.md`
   - 创建相应的版本更新文档（如果存在 `docs/version-updates/` 目录）

4. **提交信息**
   - 主项目版本更新：`🏷️ version(main): 更新主项目版本号至 x.y.z`
   - 子项目版本更新：`🏷️ version(2025To2026): 更新子项目版本号至 x.y.z`
   - 同时更新：分别提交，或在一个提交中明确说明

## 特殊场景

### 初始版本

- 项目初始版本应为 `0.1.0` 或 `1.0.0`
- 如果项目处于早期开发阶段，使用 `0.1.0`
- 如果项目已稳定并准备正式发布，使用 `1.0.0`

### 跨年版本更新

- 每年跨年时新增子项目，通常为主项目的 MINOR 版本更新（如 `0.2.0` → `0.3.0`）
- 新创建的子项目初始版本应为 `1.0.0`（表示子项目已稳定）
- 如果跨年时进行了重大架构变更，则为主项目的 MAJOR 版本更新（如 `0.2.0` → `1.0.0`）

### 紧急修复

- 紧急修复通常为 PATCH 版本更新
- 如果紧急修复涉及安全漏洞，应在 CHANGELOG 中标注为 Security 类型
- 主项目和子项目的紧急修复独立处理

## AI 助手行为规范

### 版本更新时的 AI 助手职责

1. **严格遵循语义化版本规范**
   - 根据变更内容准确判断版本号类型
   - 确保版本号格式正确

2. **同步更新所有相关文件**
   - 必须更新 README.md 中的更新记录
   - 必须更新版本号文件（如果存在）
   - 建议更新 CHANGELOG.md（如果存在）

3. **时间信息处理**
   - 更新版本时，必须执行 `date` 命令获取当前精确时间
   - 更新时间必须使用 `YYYY-MM-DD hh:mm:ss` 格式

4. **提交规范**
   - 版本更新提交必须包含 `🏷️ version:` 前缀
   - 提交信息必须清晰说明版本更新原因和变更内容

5. **禁止操作**
   - 禁止擅自创建 Git 标签（需用户明确授权）
   - 禁止跳过版本号验证
   - 禁止使用不符合规范的版本号格式
